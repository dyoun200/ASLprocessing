function bc1_XXKC%% 04/15/21 DVP- this file version is for Kincaid 503%% basiccategories1 is an example experiment using Psychophysics toolbox. 	% Task is to judge which animal is in the picture for one or two stimuli.% This task uses forced choice, e.g., given "fox" or "deer"% Respond "fox" if a fox is present, "deer" if a deer is present.% % The images are from jpeg image files made from photographs edited to % have a fixed size in pixels and be monochrome.% Masks are derived from the same set of images, checkerboard scramble.% These stimuli were used by Scharff, Palmer, and Moore (Psych Bull Rev 2011).%% Main subroutines and data structures %   DSAAAInitialize:     Initializes all routine things needed for exp.%   DSAAADoATrial:      Routine to run one trial in the experiment.%   h:                  record of all basic variables describing the exp.%   s:                  record of all major arrays used in the exp.%   cal:                record of screen calibration information%   window:             pointer to data structure for display window%% Required Files, Toolboxes, and locally written subroutines%   Local subroutines have prefix "DS" for dualshape%   Developed under MacOS 10.6.8 and Matlab R2012a (64 bit)%	Psychtoolbox 3.0.11 and associated Eyelink toolbox  %	EX routines dated 6/29/15 or later from Palmer lab%   CC routines dated 11/20/17 or later from Palmer lab%   EL routines dated 9/5/14 or later from Palmer lab%   EyelinkGetKey as modified by JP for multiple keyboards (w/ EL routines)%	Requires a calibration file in the Palmer lab style %   Eyelink needs "Eyelink Developers Kit for the Mac OS X" (1.11.1)%% Graphics conventions for space%   Mac convention is 0,0 in upper left with + down and right.  %   For my fixation-centric measures, 0,0 is screen center and + is down%   and right %% Graphics conventions for color (calibration done with CLUTS in hardware)%   SRGB:  Ideal colors with a standarized and calibrated primaries (0-1)%   RGB:   Raw integer color used by "Screen" that are (0-255)%% Bugs and things to do%   counterbalancing, rating response, data file, analysis, eyelink%% History% DVP modeled after dt7_BP.m (nameable objects with masking)% try                                     % error processing (try-catch)    % Kingfisher sync workaround    Screen('Preference', 'SkipSyncTests', 1);%     % key parametersfilename = 'test.mat';                  % placeholder in case something goes wrongos.SetResolution = 0;                   % for try-catch, updated belowh.useEyelink = 0;                       % record eye signals y/nh.LabMonitor = 2;                   	% set to 1 for lab; 2 for KingfisherPC% % Screen('Preference', 'SkipSyncTests', 1); % uncomment to run on Kingfisher% h.duration = 0.033;                       % (0.1?) stimulus duration (x0.0083; 120Hz refresh rate in lab) h.RSVPduration = 0.092;%0.025;         % stimulus durationh.maskduration = 0.092;%0.058;         % post mask durationh.ISIduration = 0;%0.100           % isi duration - adjust this for SOA  h.responsecuecolor = 'red';             % use 'red' or 'blue'h.ntrials = 16;                          % number of trials/blockh.targetContrast = 0.25;                 % contrast from 0.0 to 1.0blockvector = [1,1,2,3];           	    % list conditions to be used% blockvector = [1,1,2,3];              % dual task and single task% blockvector = [2,3];                  % single task onlyh.lr_ud = 2;                            % LR = 1; UD = 2; arrangement of stimuli on screenif(h.lr_ud == 1)    blocklabel = {'Dual Task', ...       % (1) labels for main conditions	'Left-side Single Task', ...         % (2) 	'Right-side Single Task'};           % (3) elseif(h.lr_ud == 2)    blocklabel = {'Dual Task', ...       % (1) labels for main conditions	'Top-side Single Task', ...          % (2) 	'Bottom-side Single Task'};          % (3) end% categories of images - text to be displayedh.categorynames = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u','v', 'w', 'x', 'y'};% prompt for filenameif(h.LabMonitor == 1)    startingFolder = strcat(pwd,'/Data');elseif(h.LabMonitor == 2)    startingFolder = pwd;else    startingFolder = pwd;endprompt = 'Enter filename';defaultname = 'bc1XXKC.mat';suffix = '.mat';maxlength = 50;[filestring, status] = ...    EXAskFilename(prompt,defaultname,suffix,maxlength);fullFileName = fullfile(startingFolder, filestring);filename = fullFileName% initialize other variables, graphics, etc[h, cal, window, os, s, screenRect] = DSAAAInitialize(h,os);if(h.lr_ud == 1)    % define stimulus and label coordinates    h.poscoords = [0,-0.75*h.xoffset; % category text = above fixation                   -h.xoffset, -1; % left stimulus                    h.xoffset, 1; % right stimulus                   -2*h.cuelength, 0;                     -h.cuelength, 0; % left cue                    2*h.cuelength, 0;                      h.cuelength, 0; % right cue                   ]; elseif(h.lr_ud == 2)    % define stimulus and label coordinates    h.poscoords = [0,0; % category text = above fixation                   0, -h.xoffset; % top stimulus                   0,  h.xoffset; % bottom stimulus                   0,-3*h.cuelength;                   0,-2*h.cuelength; % top cue                   0, 3*h.cuelength;                   0, 2*h.cuelength; % bottom cue                   ]; end% % calibrate eye signal before you start% Initialize eyelink, run calibrationeyefilename = 'test.edf';							% file writen to DOS machineeyefilename = strcat(fullFileName(end-10:end-4),'.edf'); %*********% intialize eyelinkel = ELInitializeEyelinkStructure(h.useEyelink,window,screenRect,cal,eyefilename);% initialize EyeLink hardwareel.calibstring = sprintf('calibration_area_proportion = %.3f %.3f',0.5, 0.5);% first one is absolute, second is relative to first% check distance to middle of stimlus% check what Alec did with stimulus spacing (4deg) **********el.fixationcriterion1 = 5*el.pixelsperdegree;		% big fixation radius crit in pixelsel.fixationcriterion2 = 2*el.pixelsperdegree;		% small fixation radius crit in pixels% this routine gets calibration doneELInitializeEyelinkSystemALT(el);						% start the hardware% reset screen	Screen(window,'FillRect',cal.backgroundRGB);	% erase screen after eyelink call    Screen(window,'Flip');% use alternate command from those in defaults to include SACCADE, etcif h.useEyelink,    Eyelink('Command', ...    'link_event_filter = LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON');end;% new code - blocking categories, mixing conditionsshufflecat = Shuffle(1:length(h.categorynames)); shufflecat2 = Shuffle(1:length(h.categorynames)); % each number corresp to category% enforce distinct categories for the forced choiceh.catblock = [shufflecat(1) shufflecat(2); % each row gives a category pair              shufflecat(3) shufflecat(4);              shufflecat(5) shufflecat(6);              shufflecat(7) shufflecat(8);              shufflecat2(1) shufflecat2(2); % each row gives a category pair              shufflecat2(3) shufflecat2(4);              shufflecat2(5) shufflecat2(6);              shufflecat2(7) shufflecat2(8);            ];% total of 128 trials per filename (64 per single/dual task condition)% will need 10 filenames to get to 600 trials;% will need 20 filenames to get to 1200 trials.% save basic structurerespMtx = [];stimMtx = [];timeMtx = [];save(filename,'h','s','respMtx','stimMtx','timeMtx','blockvector')% block loop: categories are blocked (h.catblock)%             main condition (single vs dual) is randomizedfor block = 1:size(h.catblock,1)        % populate and permute order of ST/DT conditions within block    blockvector = repmat(blockvector,[1,h.ntrials/length(blockvector)]);    conditionvector = Shuffle(blockvector);           % get the current 2AFC categories    targcat1 = h.catblock(block,1);    targcat2 = h.catblock(block,2);    response = zeros(h.ntrials,1);          % initiaze "response" vector        % determine first prompted side    % first, get balance for any dual task trials    dtBalance = EXBalance1(sum(conditionvector == 1),2);    for aa = 1:h.ntrials        if conditionvector(aa) == 1,                      % counterbalance side             s.side(aa) = dtBalance(1);              % dual task            dtBalance = dtBalance(2:end); % remove the used value        elseif conditionvector(aa) == 2,            s.side(aa) = 1;               % left side single task        elseif conditionvector(aa) == 3,            s.side(aa) = 2;               % right side single task        end;    end    % counterbalance index for target present by side    % in this task, 2 = 2nd category stim (formerly: "target present")    % and 1 = 1st category stim (formerly: "target absent")    [s.leftstimindex,s.rightstimindex] = EXBalance2(h.ntrials,2,2);        Screen(window,'Flip');            	% erase           %check refresh rate%     myflips = Screen('GetFlipInterval',window) %==0.0083 (120Hz)% 1/myflips = refresh rate in Hz% myflips = time between frames% use this as a multiplier for stim durations% flip timing:% within 4 refreshes for 500ms stim presentation% within 2 refreshes for 42ms stim presentation        % prompt and wait for keypress to start    DSDrawText(window,['Block ',int2str(block),' of ',int2str(size(h.catblock,1))],0, ...                       -120,cal.black);	% Block info display  %     DSDrawText(window,blocklabel{blocktype},0,-80,cal.black); 	% draw text     DSDrawText(window,h.categorynames{targcat1},-80,0,cal.black); 	% draw text     DSDrawText(window,'?',0,0,cal.black); 	% draw text     DSDrawText(window,h.categorynames{targcat2},80,0,cal.black); 	% draw text         DSDrawText(window,'Press any key to start or R to recalibrate',0,80,cal.black); 	% draw text     Screen(window,'Flip');           	% display it     while KbCheck(-3) == 0; end;    	% wait until a key is pressed.    KbWait(-3);                              	% wait keypress    TestRecalibrationKey(window,h,el,cal);       % recalibrate if needed    while KbCheck(-3); end;						% wait until all keys are released.    Screen(window,'Flip');                    	% erase screen     % force NO REPEAT of target within block    exemplarlist = Shuffle(1:h.numviews);       % index list for possible exemplars        % trial loop    for i = 1:h.ntrials        blocktype = conditionvector(i)        if (i == h.ntrials) % 30 views and 16 trials... this is close to no repeat            exemplarlist2 = Shuffle(1:h.numviews);            l_targetexemplar = exemplarlist2(1);            r_targetexemplar = exemplarlist2(2);        else            l_targetexemplar = exemplarlist(2*i-1); % exemplar used for display            r_targetexemplar = exemplarlist(2*i);        end        response(i) = DSAAADoATrial(i, h, cal, window, os, s, blocktype, targcat1, targcat2, l_targetexemplar, r_targetexemplar, filename, el);   % run a trial    end;    WaitSecs(h.iti);                  	% start with between trial wait  end;% End of experiment; Handle errors by restoring screen, etccatch ME                             	% matches "try" at begining     DSShutDown(os);                    	% shut down nicely    rethrow(ME);                       	% print out error messageend;if(h.useEyelink)    % shut down eyelink, display, etc    ELShutDown(el);	end% Final Exit:  restore screen, keyboard and exitDSShutDown(os);%-------------------------------------------------------------------------function response = DSAAADoATrial(i,h,cal,window,os,s,blocktype,targcat1,targcat2, l_targetexemplar, r_targetexemplar, filename, el)% DSAAADoATrial runs one trial of the experiment% 2/28/18   JP createdWaitSecs(h.iti);                        % start with between trial wait  % specify the number of framesnframes = 2;% create short names for main variablesleftstim = s.leftstimindex(i);          % stim is 1 if cat1 (former target absentrightstim = s.rightstimindex(i);        % and is 2 if cat2 (former target presentmyside = s.side(i);                     % tested side is 1 left, 2 right% define target setstudylist = Shuffle(1:length(h.objectsets));studyset = studylist(1); % this will always be imageset_devtotalstimnum = h.numobjects*h.numviews; % categories x exemplarstotalstimlist = 1:totalstimnum;% picking distractors% first, find all indices of images in cat1% cat1idx = [(targcat1-1)*h.numviews+1:targcat1*h.numviews];% cat2idx = [(targcat2-1)*h.numviews+1:targcat2*h.numviews];% remove all target category exemplars from array% totaldistlist = setdiff(totalstimlist,studycatidx);% if a target will be present, determine which frame% never show in first or last frame% framelist = Shuffle(2:nframes-1);% targetframe = framelist(1);framelist = 1:2;targetframe = 1;    % define distractor objects% totaldistlist = Shuffle(totaldistlist);% determine frame-by-frame stimulus array for each sidestimarray_L = []; % categoryviewarray_L = []; % exemplarstimarray_R = [];viewarray_R = [];%to move along shuffled distractor list without replacement% dist_count = 1;for jj = 1:nframes    %check whether target is shown this frame    if(jj == targetframe)        if(s.leftstimindex(i) ~= s.rightstimindex(i))            % stimulus present only on one side,             % pick random distractor for other side            if(s.leftstimindex(i) == 2)                stimarray_L = [stimarray_L targcat2];                viewarray_L = [viewarray_L l_targetexemplar];                                stimarray_R = [stimarray_R targcat1];                viewarray_R = [viewarray_R r_targetexemplar];            else                stimarray_R = [stimarray_R targcat2];                viewarray_R = [viewarray_R r_targetexemplar];                                stimarray_L = [stimarray_L targcat1];                viewarray_L = [viewarray_L l_targetexemplar];            end        elseif(s.leftstimindex(i) == 2 && s.rightstimindex(i)==2)            % cat 2 stimulus present on both sides, show both targets in this frame            stimarray_L = [stimarray_L targcat2];            viewarray_L = [viewarray_L l_targetexemplar];            stimarray_R = [stimarray_R targcat2];            viewarray_R = [viewarray_R r_targetexemplar];        else            % cat 1 stimulus present on both sides, show both targets in this frame            stimarray_L = [stimarray_L targcat1];            viewarray_L = [viewarray_L l_targetexemplar];            stimarray_R = [stimarray_R targcat1];            viewarray_R = [viewarray_R r_targetexemplar];        end    else        % next frame should be a random postmask -         randommaskcat = randi(8,1,2);         randommaskview = randi(30,1,2);%         randommasks = randi(50,1,2); % DVP debugging        stimarray_L = [stimarray_L randommaskcat(1)];         viewarray_L = [viewarray_L randommaskview(1)];        stimarray_R = [stimarray_R randommaskcat(2)];         viewarray_R = [viewarray_R randommaskview(2)];    end    end% specify relevant stim and the cue for the tested side% this is information relevant for the whole trial,% not individual framesif myside == 1    stim = leftstim;    otherstim = rightstim;    color1 = s.cuecolor;    color2 = s.othercolor;else    stim = rightstim;    otherstim = leftstim;	color2 = s.cuecolor;    color1 = s.othercolor;end;% saving old code in case i'm wrong about 2AFC% % picking distractors% % first, find all indices for study cat% studycatidx = [(studycategory-1)*h.numviews+1:studycategory*h.numviews];% % remove all target category exemplars from array% totaldistlist = setdiff(totalstimlist,studycatidx);% % % if a target will be present, determine which frame% % never show in first or last frame% framelist = Shuffle(2:nframes-1);% targetframe = framelist(1);%     % % define distractor objects% totaldistlist = Shuffle(totaldistlist);% % % determine frame-by-frame stimulus array for each side% stimarray_L = []; % category% viewarray_L = []; % exemplar% stimarray_R = [];% viewarray_R = [];% % %to move along shuffled distractor list without replacement% dist_count = 1;% % for jj = 1:nframes%     %check whether target is shown this frame%     if(jj == targetframe)%         if(s.leftstimindex(i) ~= s.rightstimindex(i))%             % stimulus present only on one side, %             % pick random distractor for other side%             if(s.leftstimindex(i) == 2)%                 stimarray_L = [stimarray_L targetcategory];%                 viewarray_L = [viewarray_L l_targetexemplar];%                 %                 marker = totaldistlist(dist_count);%                 dist_count = dist_count+1;%                 stimarray_R = [stimarray_R round(ceil(marker/h.numviews))];%                 myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%                 viewarray_R = [viewarray_R myview];%             else%                 stimarray_R = [stimarray_R targetcategory];%                 viewarray_R = [viewarray_R r_targetexemplar];%                 %                 marker = totaldistlist(dist_count);%                 dist_count = dist_count+1;%                 myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%                 stimarray_L = [stimarray_L round(ceil(marker/h.numviews))];%                 viewarray_L = [viewarray_L myview];%             end%         elseif(s.leftstimindex(i) == 2 && s.rightstimindex(i)==2)%             % stimulus present on both sides, show both targets in this frame%             stimarray_L = [stimarray_L targetcategory];%             viewarray_L = [viewarray_L l_targetexemplar];%             stimarray_R = [stimarray_R targetcategory];%             viewarray_R = [viewarray_R r_targetexemplar];%         else%             % no stimulus, pick random distractors%             marker = totaldistlist(dist_count);%             dist_count = dist_count+1;%             stimarray_L = [stimarray_L round(ceil(marker/h.numviews))];%             myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%             viewarray_L = [viewarray_L myview];%             %             marker = totaldistlist(dist_count);%             dist_count = dist_count+1;%             stimarray_R = [stimarray_R round(ceil(marker/h.numviews))];%             myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%             viewarray_R = [viewarray_R myview];%         end%     else%         % no other frames should have a target%         % no stimulus, pick random distractors%         marker = totaldistlist(dist_count);%         dist_count = dist_count+1;%         stimarray_L = [stimarray_L round(ceil(marker/h.numviews))];%         myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%         viewarray_L = [viewarray_L myview];% %         marker = totaldistlist(dist_count);%         dist_count = dist_count+1;%         stimarray_R = [stimarray_R round(ceil(marker/h.numviews))];%         myview = mod(marker,h.numviews);%                 if(myview == 0)%                     myview = h.numviews;%                 end%         viewarray_R = [viewarray_R myview];%     end%     % end% % % % specify relevant stim and the cue for the tested side% % this is information relevant for the whole trial,% % not individual frames% if myside == 1%     stim = leftstim;%     otherstim = rightstim;%     color1 = s.cuecolor;%     color2 = s.othercolor;% else%     stim = rightstim;%     otherstim = leftstim;% 	color2 = s.cuecolor;%     color1 = s.othercolor;% end;% % % %******** OK let's show stuff% target category for this trial% display target categories% DSDrawText(window,h.categorynames{studycategory},h.poscoords(1,1),h.poscoords(1,2),cal.black); 	% draw text% tcount adjusted below to make up for t(1) removal here% % display study stimulus% t(1) = DSDrawImage(window,0,0,s.images{studyset,studycategory,studyexemplar},s.xsize,s.ysize);% remind subject about target categories    DSDrawText(window,h.categorynames{targcat1},-80,0,cal.black); 	% draw text     DSDrawText(window,'?',0,0,cal.black); 	% draw text     DSDrawText(window,h.categorynames{targcat2},80,0,cal.black); 	% draw text    % and pre-cueif(blocktype == 1) % dual task    DSDrawLine(window ,s.cuecolor,h.poscoords(4,1),h.poscoords(4,2),h.poscoords(5,1),h.poscoords(5,2), 2);    DSDrawLine(window ,s.cuecolor,h.poscoords(6,1),h.poscoords(6,2),h.poscoords(7,1),h.poscoords(7,2), 2);else%if(blocktype==2)    DSDrawLine(window ,color1,h.poscoords(4,1),h.poscoords(4,2),h.poscoords(5,1),h.poscoords(5,2), 2);    DSDrawLine(window ,color2,h.poscoords(6,1),h.poscoords(6,2),h.poscoords(7,1),h.poscoords(7,2), 2);% else%     DSDrawLine(window ,color1, -2*h.cuelength, 0, -h.cuelength, 0, 1);%     DSDrawLine(window ,color1, 2*h.cuelength, 0, h.cuelength, 0, 1);end% and fixationif (h.lr_ud ~= 2)    DSDrawFixation(window,h.fixationsize,cal.black);end% displayScreen(window,'Flip');                 	 WaitSecs(h.studytime);% remove study and wait - blank screen% add fixationDSDrawFixation(window,h.fixationsize,cal.black);% Screen(window,'Flip');   [VBLTimestamp(1) StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen(window,'Flip');vbl_counter = 1;vbl(vbl_counter) = VBLTimestamp(1);    % first flip before the loop% disp('fixation on:')% disp(num2str(VBLTimestamp))%additions from John to test timing  testtime = 1;if(testtime)    screens = Screen('Screens');    % usually "0", allows for multi. monitors    screenNumber = max(screens);    % use the external monitor    resolution = Screen('Resolution', screenNumber);    criterion = 2;        % flip delay (ms) for a bad frame    % set frequency of frame updates    waitframes = 1;     % 1 for full speed; 2 for half speed, etc    ifi = Screen('GetFlipInterval', window);    fprintf('\nBad frame criterion (ms):   %6.1f\n',criterion);    fprintf('Frame rate (Hz):            %6.1f\n',resolution.hz);    fprintf('WaitFrames:                 %6.0f\n',waitframes);    fprintf('Expected Flip Interval (ms):%6.1f\n\n',1000*ifi*waitframes);endELTrialStart(el,i);				% turn on eyelink recording% monitor fixation acquisitionfixationstatus = 1;  %will be set to 0 if successfully fixated for enough timebreakcounter = 1;go_on_to_next = 0; % move to next trial if no fixation acquired right awaywhile(fixationstatus)    if(breakcounter < 4)        [fixationstatus,ox,oy] = ELEstablishFixation(el,h.fixationtime);	% wait for fixation        ELErrorFeedback(el,fixationstatus);				% output error sound if necessary        breakcounter = breakcounter+1;    else%         ELErrorFeedback(el,1);				% output error sound if necessary        DSDrawText(window,'NO FIXATION FOUND',0,-40,cal.black); 	% draw text         DSDrawText(window,'Press any key to go on to next trial or R to recalibrate',0,0,cal.black); 	% draw text         Screen(window,'Flip');           	% display it         while KbCheck(-3) == 0; end;    	% wait until a key is pressed.        KbWait(-3);                              	% wait keypress        TestRecalibrationKey(window,h,el,cal);       % recalibrate if needed        while KbCheck(-3); end;						% wait until all keys are released.        Screen(window,'Flip');                    	% erase screen         go_on_to_next = 1;        fixationstatus = 0;    endendif(go_on_to_next)    % clean up and move on to next trial    % free up memory used for textures%             Screen('Close',t(1));    response = 99;        % save data here and quit trial    load(filename)    %stimMtx: studyset studycat studyexemplar leftobjstream leftviewstream rightobjstream rightviewstream    %timeMTX: VBLTimestamp and VBLTimestampISI    %respMtx: same    stimMtx = [stimMtx; targcat1 targcat2 l_targetexemplar r_targetexemplar stimarray_L viewarray_L stimarray_R viewarray_R];    timeMtx = [timeMtx; zeros(1,13).*NaN];    respMtx = [respMtx; blocktype leftstim rightstim myside 99 99 NaN 0 0];    save(filename,'respMtx','stimMtx','-append')else    % fixation was acquired so continue with the trial        % loop the next part over frames *******    tcount = 1; % for cleanup    VBLcount = 2;    VBLcountISI = 1;    % loop over all frames including last; answer prompts are blank    for ii = 1:nframes        % get stimuli from left and right array        stim_L = stimarray_L(ii)        view_L = viewarray_L(ii)         stim_R = stimarray_R(ii)        view_R = viewarray_R(ii)%         if(blocktype < 4)        if ii == 1 % stimulus frame            DSDrawFixation(window,h.fixationsize,cal.black);    % include fixation            t(tcount) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...                s.xsize,s.ysize);            t(tcount+1) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...                s.xsize,s.ysize);            tcount = tcount+2; % FOR CLEANUP        else % mask frame                DSDrawFixation(window,h.fixationsize,cal.black);    % include fixation            t(tcount) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.imagesMASK{studyset,stim_L,view_L}, ...                s.xsize,s.ysize);            t(tcount+1) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.imagesMASK{studyset,stim_R,view_R}, ...                s.xsize,s.ysize);            tcount = tcount+2; % FOR CLEANUP        end%         else%             DSDrawFixation(window,h.fixationsize,cal.black);    % include fixation%             if(blocktype == 4)%                 t(tcount) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...%                     s.xsize,s.ysize);%             elseif(blocktype == 5)%                 t(tcount) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...%                     s.xsize,s.ysize);%             end%             tcount = tcount+1; % FOR CLEANUP%         end                % present and record timing        [VBLTimestamp(VBLcount)] = Screen(window,'Flip');        vbl_counter = vbl_counter+1;        vbl(vbl_counter) = VBLTimestamp(VBLcount);%         VBLcount = VBLcount+1                if(ii==1) % if stimulus frame            %monitor fixation maintained and give feedback            fixationstat(ii) = ELCheckFixationForInterval_Relative(el,h.RSVPduration,VBLTimestamp(VBLcount),ox,oy);	% test fixation            VBLcount = VBLcount+1;        else % otherwise this is a mask frame            %monitor fixation maintained and give feedback            fixationstat(ii) = ELCheckFixationForInterval_Relative(el,h.maskduration,VBLTimestamp(VBLcount),ox,oy);	% test fixation            VBLcount = VBLcount+1;        end        %remove stim and insert ISI%         DSDrawFixation(window,h.fixationsize,cal.black);%         [VBLTimestampISI(VBLcountISI) StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen(window,'Flip');%         vbl_counter = vbl_counter+1;%         vbl(vbl_counter) = VBLTimestampISI(VBLcountISI);%             %         fixationstatISI(ii) = ELCheckFixationForInterval_Relative(el,h.ISIduration,VBLTimestampISI(VBLcountISI),ox,oy);	% test fixation%         VBLcountISI = VBLcountISI+1;    end        %    remove stim and timestamp to get duration - one flip        DSDrawFixation(window,h.fixationsize,cal.black);        [VBLTimestampISI(VBLcountISI) StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen(window,'Flip');        vbl_counter = vbl_counter+1;        vbl(vbl_counter) = VBLTimestampISI(VBLcountISI);                    fixationstatISI(ii) = ELCheckFixationForInterval_Relative(el,h.ISIduration,VBLTimestampISI(VBLcountISI),ox,oy);	% test fixation        VBLcountISI = VBLcountISI+1;            vbl.*1000;    diff(vbl.*1000);    times = diff(vbl(2:end))    disp('VBL above')    %should be %     if(times == [0.050 0.0333 0.025 0.0333 0.050])%         disp('trial ok')%     else%         disp(times)%     end%     fprintf('Max Flip Interval (ms):     %6.1f\n',1000*max(times));%     fprintf('Mean Flip Interval (ms):    %6.1f\n',1000*mean(times));%     fprintf('Min Flip Interval (ms):     %6.1f\n',1000*min(times));%     fprintf('Range of Flip Interval (ms):%6.1f\n\n',1000*max(times)-1000*min(times));%     fprintf('Number of tested frames:    %6.0f\n',length(times));        % if any of the above returns 1, fixation was broken    % play an error tone and go to next trial    if(sum([fixationstat fixationstatISI]) > 0)        ELErrorFeedback(el,1);				% output error sound if necessary        % display error message        DSDrawText(window,'FIXATION LOST',0,-40,cal.black); 	% draw text         DSDrawText(window,'Press any key to resume or R to recalibrate',0,0,cal.black); 	% draw text         Screen(window,'Flip');           	% display it         while KbCheck(-3) == 0; end;    	% wait until a key is pressed.        KbWait(-3);                              	% wait keypress        TestRecalibrationKey(window,h,el,cal);       % recalibrate if needed        while KbCheck(-3); end;						% wait until all keys are released.        Screen(window,'Flip');                    	% erase screen         % clean up and move on to next trial        % free up memory used for textures        for i=1:tcount-1, %adjusted for numscreens            Screen('Close',t(i));        end;        response = 99;            % save data here and quit trial        load(filename)        %stimMtx: studyset studycat studyexemplar leftobjstream leftviewstream rightobjstream rightviewstream        %timeMTX: VBLTimestamp and VBLTimestampISI        %respMtx: same        stimMtx = [stimMtx; targcat1 targcat2 l_targetexemplar r_targetexemplar stimarray_L viewarray_L stimarray_R viewarray_R];        timeMtx = [timeMtx; VBLTimestamp VBLTimestampISI];        respMtx = [respMtx; blocktype leftstim rightstim myside 99 99 NaN 0 0];        save(filename,'respMtx','stimMtx','-append')    else        % stop testing after 2nd mask            ELTrialEnd(el);									%turn off eyelink recording%         % get final frame for postmask%             stim_L = stimarray_L(end);%             view_L = viewarray_L(end);   %             stim_R = stimarray_R(end);%             view_R = viewarray_R(end);% %         % display post-mask - until response%         if (blocktype < 4)%             t(tcount) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...%                 s.xsize,s.ysize);% %             t(tcount+1) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...%                 s.xsize,s.ysize);%         else%             if (blocktype == 4)%                 t(tcount) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...%                     s.xsize,s.ysize);%             elseif (blocktype == 5)%                 t(tcount) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...%                     s.xsize,s.ysize);%             end%         end% %         % draw study and cues and wait till response%     %     t(tcount+2) = DSDrawImage(window,0,-1*h.xoffset,s.images{studyset,studycategory,studyexemplar},s.xsize,s.ysize);%     %     DSDrawLine(window ,color1, -2*h.cuelength, 0, -h.cuelength, 0, 1);%     %     DSDrawLine(window ,color2, 2*h.cuelength, 0, h.cuelength, 0, 1);%     %     DSDrawText(window,'?',0,0,cal.black);	%         Screen(window,'Flip'); % remind subject about target categories    DSDrawText(window,h.categorynames{targcat1},-80,0,cal.black); 	% draw text     DSDrawText(window,'?',0,0,cal.black); 	% draw text     DSDrawText(window,h.categorynames{targcat2},80,0,cal.black); 	% draw text    % DSDrawText(window,h.categorynames{studycategory},h.poscoords(1,1),h.poscoords(1,2),cal.black); 	% draw text%         t(tcount+2) = DSDrawImage(window,0,0,s.images{studyset,studycategory,studyexemplar},s.xsize,s.ysize);%         if (blocktype < 4)%             t(tcount+2) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...%                 s.xsize,s.ysize);% %             t(tcount+3) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...%                 s.xsize,s.ysize);%         else%             if(blocktype == 4)%                 t(tcount+1) = DSDrawImage(window,h.poscoords(2,1),h.poscoords(2,2),s.images{studyset,stim_L,view_L}, ...%                     s.xsize,s.ysize);%             elseif(blocktype == 5)%                 t(tcount+1) = DSDrawImage(window,h.poscoords(3,1),h.poscoords(3,2),s.images{studyset,stim_R,view_R}, ...%                     s.xsize,s.ysize);%             end%         end        DSDrawLine(window ,color1, h.poscoords(4,1),h.poscoords(4,2), h.poscoords(5,1),h.poscoords(5,2),  2);        DSDrawLine(window ,color2, h.poscoords(6,1),h.poscoords(6,2),h.poscoords(7,1),h.poscoords(7,2),2);%         DSDrawText(window,'?',0,0,cal.black);% %         if (blocktype < 4)%             tcount = tcount+4; %for cleanup = total number of images to clear%         else%             tcount = tcount+2;%         end                Screen(window,'Flip'); %to delay onset of study/postcue        Snd('Play',MakeBeep(h.responsecuefrequency,h.responsecuetime));        % get response        if(myside == 1)            % query stim on left side            [response abort rxt] = DSGetResponse(h, stim, h.yeskeycode_L, h.nokeycode_L, h.guessyeskeycode_L, h.guessnokeycode_L);        elseif(myside == 2)            % query stim on right side              [response abort rxt] = DSGetResponse(h, stim, h.yeskeycode_R, h.nokeycode_R, h.guessyeskeycode_R, h.guessnokeycode_R);        end         % default yes/no buttons        % [response abort rxt] = DSGetResponse(h, stim, h.yeskeycode, h.nokeycode);        Screen(window,'Flip');                  % erase cue            response2 = NaN;        abort2 = 0;        recalib2 = 0;        %for dual task, ask about the other stim as well        if(blocktype==1)            % draw cue and wait till response%             DSDrawText(window,h.categorynames{studycategory},h.poscoords(1,1),h.poscoords(1,2),cal.black); 	% draw text% remind subject about target categories    DSDrawText(window,h.categorynames{targcat1},-80,0,cal.black); 	% draw text     DSDrawText(window,'?',0,0,cal.black); 	% draw text     DSDrawText(window,h.categorynames{targcat2},80,0,cal.black); 	% draw text                %             t(tcount) = DSDrawImage(window,0,0,s.images{studyset,studycategory,studyexemplar},s.xsize,s.ysize);%             tcount = tcount+1;            DSDrawLine(window ,color2, h.poscoords(4,1),h.poscoords(4,2),h.poscoords(5,1),h.poscoords(5,2), 2);            DSDrawLine(window ,color1, h.poscoords(6,1),h.poscoords(6,2),h.poscoords(7,1),h.poscoords(7,2), 2);%             DSDrawText(window,'?',0,0,cal.black);	            Screen(window,'Flip');                     	             % get response            if(myside == 1)                %query other, right side                [response2 abort2 dummy] = DSGetResponse(h, otherstim, h.yeskeycode_R, h.nokeycode_R, h.guessyeskeycode_R, h.guessnokeycode_R);            elseif(myside == 2)                %query oher, left side                [response2 abort2 dummy] = DSGetResponse(h, otherstim, h.yeskeycode_L, h.nokeycode_L, h.guessyeskeycode_L, h.guessnokeycode_L);            end            % % single key codes            %     [response2 abort2 dummy] = DSGetResponse(h, otherstim, h.yeskeycode, h.nokeycode);            Screen(window,'Flip');                  % erase cue           end        if response~=stim            if(response-2 ~= stim) %adjust for guesses                Snd('Play',MakeBeep(h.errorfeedbackfrequency,h.errorfeedbacktime));            else                Snd('Play',MakeBeep(h.correctfeedbackfrequency,h.errorfeedbacktime));            end        else            Snd('Play',MakeBeep(h.correctfeedbackfrequency,h.errorfeedbacktime));        end        WaitSecs(0.3); % always wait to make trial length consistent        if(blocktype==1)            if response2~=otherstim                if(response2-2 ~= otherstim) %adjust for guesses                    Snd('Play',MakeBeep(h.errorfeedbackfrequency,h.errorfeedbacktime));                else                    Snd('Play',MakeBeep(h.correctfeedbackfrequency,h.errorfeedbacktime));                end            else                Snd('Play',MakeBeep(h.correctfeedbackfrequency,h.errorfeedbacktime));            end        end        % output data here        load(filename);        %stimMtx: studyset studycat studyexemplar targetframe# leftobjstream leftviewstream rightobjstream rightviewstream        %timeMTX: VBLTimestamp and VBLTimestampISI        %respMtx: same        stimMtx = [stimMtx; targcat1 targcat2 l_targetexemplar r_targetexemplar stimarray_L viewarray_L stimarray_R viewarray_R];        timeMtx = [timeMtx; VBLTimestamp VBLTimestampISI];        respMtx = [respMtx; blocktype leftstim rightstim myside response response2 rxt abort abort2];        save(filename,'respMtx','stimMtx','timeMtx','-append');        % free up memory used for textures        for i=1:tcount-1, %adjust for numscreens             Screen('Close',t(i));        end;        % check abort        if abort || abort2            DSShutDown(os);            error('DSTestAbortKey:Abort','Aborting Experiment due to abort key');        end;    endend; % this ends the trial with fixation check%-------------------------------------------------------------------------function [h, cal, window, os, s, screenRect] = DSAAAInitialize(h,os)% DSAAAInitialize initializes everything for the experiment% 2/28/18   JP created% monitor parameters that depend on the exact monitorif h.LabMonitor == 1,    h.hres = 1024;                    	% north lab w/ eyelink 1000    h.vres = 640;                       % horiz and vert spatial res.    h.tres = 120;						% temporal resolution in hertz    h.pixelsperdegree = 23.8;			% pixels per degree (new lab setup)    h.calibrationfile = 'sony11_041421.cal';	% lab calibration file	os.SetResolution = 1;               % 1 to reset resolution, 0 to notelse    if h.LabMonitor == 2,        h.hres = 1920; 						% generic values for my office        h.vres = 1080;                       % horiz and vert spatial res.        h.tres = 60;						% temporal resolution in hertz        h.pixelsperdegree = 23.8;			% pixels per degree ?        h.calibrationfile = 'sony11_041421.cal'; % calibration file         os.SetResolution = 0;             	% 1 to set resolution, 0 to not    else        h.hres = 1280; 						% generic values for my office        h.vres = 800;                       % horiz and vert spatial res.        h.tres = 60;						% temporal resolution in hertz        h.pixelsperdegree = 23.8;			% pixels per degree ?        h.calibrationfile = 'sony11_041421.cal'; % calibration file         os.SetResolution = 0;             	% 1 to set resolution, 0 to not    endend;% spatial variables (specified in degrees and converted to pixels)h.fixationsizeDeg = 0.5;                % (0.5) size of fixation in degreesh.fixationsize = h.fixationsizeDeg*h.pixelsperdegree;	% size in pixelsh.xoffsetDeg = 4;                     	% (4) horiz shift of image ctr Degh.xoffset = h.xoffsetDeg*h.pixelsperdegree;             % offset in pixelsh.cuelengthDeg = 0.5;                  	% (.5) cue length and space fr fixh.cuelength = h.cuelengthDeg*h.pixelsperdegree;         % length in pixels% time variables (specified in seconds)h.fixationtime = 0.6;                   % (.5) duration in sec of fixation h.aftertime = 0.5;                      % (.5) duration of blanks h.studytime = 1.5;                      % (1.0) duration of initial study% h.maskduration = 0.200;%0.04;                   % (0.2) duration of maskh.iti = 1.0;                            % (1.0) duration of intertrial inth.premaskduration = 0.200;%0.04;% define relevant keysh.abortkeycode = KbName('a');			% abort keyh.recalkeycode = KbName('r');if(h.LabMonitor == 2)%     h.yeskeycode = KbName('d');				% "yes" key%     h.nokeycode = KbName('s');				% "no" key   %   here, "yes" = category word on the right%   "no" = category word on the left    h.yeskeycode_L = KbName('y');            % likely yes - left side stim    h.guessyeskeycode_L = KbName('t');       % guess yes    h.guessnokeycode_L = KbName('e');        % guess no    h.nokeycode_L = KbName('w');             % likely no    h.yeskeycode_R = KbName('h');            % likely yes - right side stim    h.guessyeskeycode_R = KbName('g');       % guess yes    h.guessnokeycode_R = KbName('d');        % guess no    h.nokeycode_R = KbName('s');             % likely noelse    %h.yeskeycode = KbName('.');				% "yes" key    %h.nokeycode = KbName('0');				% "no" key%     h.yeskeycode_L = KbName('7');            % likely yes - left side stim%     h.guessyeskeycode_L = KbName('4');       % guess yes%     h.guessnokeycode_L = KbName('1');        % guess no%     h.nokeycode_L = KbName('0');             % likely no%     h.yeskeycode_R = KbName('9');            % likely yes - right side stim%     h.guessyeskeycode_R = KbName('6');       % guess yes%     h.guessnokeycode_R = KbName('3');        % guess no%     h.nokeycode_R = KbName('.');             % likely no%   here, "yes" = category word on the right%   "no" = category word on the left    h.yeskeycode_L = KbName('7');            % likely yes - left side stim    h.guessyeskeycode_L = KbName('7');       % guess yes    h.guessnokeycode_L = KbName('4');        % guess no    h.nokeycode_L = KbName('1');             % likely no    h.yeskeycode_R = KbName('9');            % likely yes - right side stim    h.guessyeskeycode_R = KbName('-');       % guess yes    h.guessnokeycode_R = KbName('+');        % guess no    h.nokeycode_R = KbName('3');             % likely noend% luminance and contrast variablesh.background = 0.52;                     % (1) fract. of RGB for background% h.targetContrast = 1.0;                 % (1) contrast rel. to background% text variablesh.Font = 'Courier';                    	% 'Courier' for a fixed size fonth.FontStyle = 0;                     	% (0) 0 for normal, 1 for boldh.FontSize = 24;                      	% (24) default font size in points% misc variablesh.initialseed = ClockRandSeed;			% initialize random numbers & saveh.errorfeedbacktime = 0.25;             % tone feedback on errors onlyh.errorfeedbackfrequency = 300;      	% frequencies for all tonesh.correctfeedbackfrequency = 700;      	% frequencies for all tonesh.responsecuetime = 0.03;h.responsecuefrequency = 1200;% set resolution if specifiedpixelsize = 32;                       	% use full color (32 bit mode)if os.SetResolution == 1	os.oldRes = SetResolution(0,h.hres,h.vres,h.tres,pixelsize);	end;% get calibration info amd make Gamma correction array (inverse gamma)cal = CCGetCalibration(h.calibrationfile);	% get calibration info gammaInverse = CCMakeInverseGamma(cal);     % calc lookup table for calib% set values for OpenWindow callmyscreen = 0;                        	% use 0 for single monitor% calculations about color used "standardized" SRGB (0-1)backgroundSRGB = [h.background h.background h.background];	cal.backgroundRGB = round(255*backgroundSRGB);  	% make integer RGB (0-255)cal.pixelsperdegree = h.pixelsperdegree;  %added for eyelink% create graphics "window" for entire screen with a given background color% [] arg causes default window size (entire screen)[window,screenRect]=Screen(myscreen,'OpenWindow',cal.backgroundRGB,[],pixelsize);	BackupCluts(myscreen);                    	% save cluts (restore by "sca")%  loads the gamma correction into hardwareScreen('LoadNormalizedGammaTable', myscreen, gammaInverse);   HideCursor;                             % hide cursor during displays% DY ListenChar(2);                      	% flush char buffer% set up cue color based on h.responsecuecolorif strcmp(h.responsecuecolor,'red'),    s.cuecolor = cal.red;    s.othercolor = cal.blue;else    s.cuecolor = cal.blue;    s.othercolor = cal.red;end;% set text properties of windowScreen('TextFont',window,h.Font);Screen('TextSize',window,h.FontSize);      Screen('TextStyle',window,h.FontStyle);Screen('Preference', 'TextAntiAliasing', 0); % want text in binary colors% shape descriptions% current version uses set 1 for targets and set 2 for masks% h.objectsets = {'Foam2' 'Duplo4'}; % possible: 'Crumple2' 'Foam2' 'Duplo4'h.objectsets = {'Imgset_dev'};h.numsets = length(h.objectsets);h.numobjects = length(h.categorynames);         % NUM CATEGORIES         % number of objects in each set h.numviews = 1;                % NUM OBJECTS PER CATEGORY        % number of views for each objecth.filedir = 'C:\Toolbox\BC1_code\BC1_code\ASL_Images\asl_signs';% Load images into memory: "images array has indexes (set,object,view)[s.images, s.imagesMASK, s.ysize0,s.xsize0] = DSImagesLoad(h);size(s.images) %debugsize(s.imagesMASK)%debugs.ysize = s.ysize0(1,1,1);                % all sizes are the sames.xsize = s.xsize0(1,1,1);%-------------------------------------------------------------------------function DSDrawFixation(window,size,color)% DSDrawFixation draws a fixation point consisting of a cross% pass in:  window, size in pixels and color % symmetric fixation works bit differently for different systems???% 2/28/18   JP created from prior uses[xc,yc] = EXGetCenter(window);half = round((size-1)/2);% this method works in main labScreen('DrawLine',window,color,xc,yc,xc,yc+half);Screen('DrawLine',window,color,xc,yc,xc,yc-half);Screen('DrawLine',window,color,xc,yc,xc+half,yc);Screen('DrawLine',window,color,xc,yc,xc-half,yc);%--------------------------------------------------------------------function mytexture = DSDrawImage(window,xx,yy,image,xs,ys)% DSDrawImage draws an image array% Pass in:% xx,yy:  location of image center relative to screen center% image:  pixel array% xs,ys:  size of pixel array% returns mytexture (a pointer) so one can recover the memory% 2/28/18   JP created[xc,yc] = EXGetCenter(window);          % get center of screen x = xx+xc-round(xs/2);                  % calculate desired locationy = yy+yc-round(ys/2);mytexture = Screen('MakeTexture', window, image);   % create texturedrect = [x y x+xs y+ys];                % drect specifying locationScreen('DrawTexture',window,mytexture,[],drect);    % draw it%-------------------------------------------------------------------------function DSDrawLine(window,color,x1,y1,x2,y2,w)% DSDrawLine draws a single line% uses position relative to center of screen instead of upper left% 2/28/18   JP created from prior uses[xc,yc] = EXGetCenter(window);Screen('DrawLine',window,color,xc+x1,yc+y1,xc+x2,yc+y2,w);% ------------------------------------------------------------------------function DSDrawText(window,s,x,y,color)% DSDrawText(window,s,x,y,color);% draw text centered at position x,y relative to center in a given color% pass in window, string, x,y position relative to center, and color% 2/28/18   JP updated from prior uses[xcenter,ycenter] = EXGetCenter(window);	% get center of screen if ~isnan(s),                               % skip if no text    rect = Screen(window,'TextBounds',s); 	% TextBounds replaces TextWidth    width=rect(3);                       	% 3rd element is width of text    height = rect(4);                       % 4th is height    xx = xcenter-width/2+x;               	% figure x coordinate    yy = ycenter-height/2+y;              	% figure y coordinateelse    xx = xcenter;                           % default to center    yy = ycenter;end;Screen(window,'DrawText',s,xx,yy,color);   	% draw with psychtoolbox call%--------------------------------------------------------------------function [response,abort,rt] = DSGetResponse(h, stim, yeskeycode, nokeycode, guessyeskeycode, guessnokeycode)% DSGetResponse checks for specified key and returns code.% 2/28/18   JP created from prior uses% correct side mapping should be passed to this fxn when using% response ratingsstart = GetSecs;response = -1;									% initial check of key status[isPressed,~,keycode] = KbCheck(-3);	% check for desired keys% wait till no key pressed (to avoid keys held down)if isPressed        				while DSTestResponse(h,isPressed,keycode,yeskeycode,nokeycode) == 1;	[isPressed,~,keycode] = KbCheck(-3); 	end;end% wait till new key pressedwhile DSTestResponse(h,isPressed,keycode,yeskeycode,nokeycode) == 0;	[isPressed,~,keycode] = KbCheck(-3); end;abort = DSTestAbortKey(h);	% check for abort % pause or desired key is pressedif abort	rt = 0;								% pause key pressed, abort 	response = -1;						% mark with -1else	rt = GetSecs-start;					% good trial	if keycode(yeskeycode) == 1, response = 2; end;	if keycode(nokeycode) == 1, response = 1; end;%     if keycode(guessyeskeycode) == 1, response = 4; end;% 	if keycode(guessnokeycode) == 1, response = 3; end;end;% this is now done in-trial - not after each response% % give tone feedback for errors (nothing for correct)% if response ~= stim%     if(response-2 ~= stim) %adjust for guesses%         Snd('Play',MakeBeep(h.errorfeedbackfrequency,h.errorfeedbacktime));%     end% end;%--------------------------------------------------------------------function [images, imagesMASK, ysize,xsize] = DSImagesLoad(h)% DSImagesLoad loads in all image files into image array "images"% returns cell array of images and an array of image sizes% filenames are hard coded in this routine% The .jpg files were photographs that were edited to have% a fixed size in pixels and be monochrome.% 10/3/08   AS created% 2/28/18   JP rewrote and simplfied% 3/4/18    now reads different sets into a third indexxsize = zeros(h.numsets,h.numobjects,h.numviews); % reserve memoryysize = zeros(h.numsets,h.numobjects,h.numviews);images = cell(h.numsets,h.numobjects,h.numviews);imagestmp = cell(h.numsets,h.numobjects,h.numviews);imagesMASK = cell(h.numsets,h.numobjects,h.numviews);% contains images, xsize, ysize% load('nameable_objects_06102019.mat')% load all images from a disk file        for i = 1:h.numobjects                        name = DSImagesFilename(h,i);   % get the image filenames                                % read and convert into desired grey level scale                [imagestmp{1,i,1}(:,:), ysize(1,i,1), xsize(1,i,1)] = ...                    DSImagesConvert(h.targetContrast,char(name));                  % DVP fix - showing 3 in a row? img is 100x300 but ysize is                % 100 and so is xsize                images{1,i,1} = imagestmp{1,i,1}(:,1:100);                                % DVP commented out, no masks here%                 name2 = DSImagesFilenameMASK(h,i,j,k);   % get the image filenames                % read and convert into desired grey level scale%                 [imagesMASK{k,i,j}(:,:), ysize(k,i,j), xsize(k,i,j)] = ...%                     DSImagesConvert(h.targetContrast,char(name2));             end        end        %     else % for mask set        for i = 1:h.numobjects          % index for objects in a set            for j = 1:h.numviews            % index for the views                [i j k];                name = DSImagesFilenameMASK(h,i,j,k);   % get the image filenames                % read and convert into desired grey level scale                % hard code masks to 100% contrast                [imagesMASK{k,i,j}(:,:), ysize(k,i,j), xsize(k,i,j)] = ...                    DSImagesConvert(1.0,char(name));                   end        end%     endend;% load('nameable_objects_06102019.mat') % nameable objects - for debugging% h.numsets% h.numobjects% h.numviews% % % load all images from a disk file% for k = 1:h.numsets% %     if k == 1 % for stimulus set%         for i = 1:h.numobjects          % index for objects in a set%             for j = 1:h.numviews            % index for the views%                 name = DSImagesFilename(h,i,j,k);   % get the image filenames%                 %                 % read and convert into desired grey level scale%                 [imagestmp{k,i,j}(:,:), ysize(k,i,j), xsize(k,i,j)] = ...%                     DSImagesConvert(h.targetContrast,char(name));  % %                 % DVP fix - showing 3 in a row? img is 100x300 but ysize is%                 % 100 and so is xsize%                 images{k,i,j} = imagestmp{k,i,j}(:,1:100);%                 %                 % DVP commented out, no masks here% %                 name2 = DSImagesFilenameMASK(h,i,j,k);   % get the image filenames% %                 % read and convert into desired grey level scale% %                 [imagesMASK{k,i,j}(:,:), ysize(k,i,j), xsize(k,i,j)] = ...% %                     DSImagesConvert(h.targetContrast,char(name2)); %             end%         end%         % %     else % for mask set% %         for i = 1:h.numobjects          % index for objects in a set% %             for j = 1:h.numviews            % index for the views% %                 name = DSImagesFilenameMASK(h,i,j,k);   % get the image filenames% % % %                 % read and convert into desired grey level scale% %                 [images{k,i,j}(:,:), ysize(k,i,j), xsize(k,i,j)] = ...% %                     DSImagesConvert(h.targetContrast,char(name));       % %             end% %         end% %     end% end;% save('dt5test.mat','images','ysize','xsize')%--------------------------------------------------------------------    function Image = DSImagesFilename(h, ImageIndex)% DSImageFilename returns a filename with image data.% pass in:  h, imageindex, objectindex, imageset index% returns:  long list of filenames in a cell array% hard coded for 6 object sets (A-F) each having 6 views (01-06). % imset could be: 'Crumple2' 'Foam2' 'Duplo4'% 04/23/07  AS wrote% 2/28/18   JP updated slightlyimset = char(h.objectsets(imset));mycats = h.categorynames;for mc = 1:length(h.categorynames)Imagelist = fullfile(h.filedir,  [ strcat( mycats(mc),'.jpg')]);             endImage = Imagelist(ImageIndex, object); % return relevant filename%--------------------------------------------------------------------function Image = DSImagesFilenameMASK(h, ImageIndex, object, imset)% DSImageFilename returns a filename with image data.% pass in:  h, imageindex, objectindex, imageset index% returns:  long list of filenames in a cell array% hard coded for 6 object sets (A-F) each having 6 views (01-06). % imset could be: 'Crumple2' 'Foam2' 'Duplo4'% 04/23/07  AS wrote% 2/28/18   JP updated slightlyimset = char(h.objectsets(imset));Imagelist = {};for i = 1:240Imagelist = [Imagelist strcat('mask',num2str(i),'.jpg')];end	Imagelist = reshape(Imagelist,[8 30]);Image = Imagelist(ImageIndex, object); % return relevant filename%--------------------------------------------------------------------function [sa,xs,ys] = DSImagesConvert(contrast,file)% DSImagesConvert reads in a jpeg file and returns a monochrome array% pass in:  filename for a single image% returns:  as = converted array, and the x and y size in arrays% 09/05/08  AS added from JP's test code% 2/28/18   JP updated slightly% read in filea = imread(file);                       % read jpg file into arrayinfo = imfinfo(file);					% get info from jpg filexs = info.Width;                        % get size of imageys = info.Height; % turn rgb 3 arrays into a single monochrome arraya1 = double(a(:,:));					% use double instead of uint8minpixel = min(min(a1));maxpixel = max(max(a1));meanpixel = mean(mean(a1));%Scale pixel values between 0 and 255:%contrast is adjusted by squashing cell values towards whitesa = contrast.*(a1 - meanpixel) + meanpixel;% sa = round(Scale(a1)*(255*contrast)+((1-contrast)*255));%--------------------------------------------------------------------function DSShutDown(os)% DSShutDown exits program nicely.  No Eyelink code yet% 2/28/18   JP created from prior usessca;                                    % close screens and restore cluts% DY ListenChar(0);                          % flush char bufferif os.SetResolution == 1                % restore initial resolution	SetResolution(0,os.oldRes);end;WaitSecs(0.2);                          % allow extra time for paranoia %--------------------------------------------------------------------function flag = DSTestAbortKey(h)% DSTestAbortKey tests for abort key and returns flag% 2/28/18   JP created from prior usesflag = 0;                               % default is no abort, rtn 0[isPressed,~,keycode] = KbCheck(-3);	% check for pause or abort keyif isPressed	if keycode(h.abortkeycode),        flag = 1;                       % if abort found, return 1	end;end%--------------------------------------------------------------------function flag = TestRecalibrationKey(window,h,el,cal)% flag = TestRecalibrationKey(window,h,el,st,os)% routine to perform an eyelink recalibration in the middle of an experiment% 9/5/14    JP took from Serap's FilterColor15 and modified for OS10% 4/16/15   removed code that changed cluts before eyelink call% 6/28/15   removed os from arg% 1/13/16   modified args for changed RecreateWindowflag = 0;[~,~,keycode] = KbCheck(-3);                   	% get current keysif  keycode(h.recalkeycode) && el.UseEyelink    flag = 1;    fprintf('\nRecalibration requested \n\n');	    s = 'Recalibration Requested; press any key to continue';     DSDrawText(window,s,0,0,cal.black);	% give warning msg for calibration    Screen('Flip',window);    while KbCheck(-3); end;						% wait until all keys are released.    KbWait(-3);									% wait for any key    EyelinkDoTrackerSetup(el);                  % eyelink routine for calibration                      RecreateWindow(window,h,cal);                % reset window properties        s = 'Press any key to continue';    DSDrawText(window,s,0,0,cal.black)				Screen('Flip',window);    while KbCheck(-3); end;						% wait until all keys are released.    KbWait(-3);									% wait for any key	Screen('Flip',window);end;%--------------------------------------------------------------------function result = DSTestResponse(h,isPressed,keycode,key1,key2)% DSTestResponse returns 1 when good key is pressed, 0 if bad% 2/28/18   JP created from prior usesresult = 0;if isPressed == 1	if keycode(key1) == 1, result = 1;  % tests THREE possibiities	elseif keycode(key2) == 1, result = 1; %     elseif keycode(keyguess1) == 1, result = 1;%     elseif keycode(keyguess2) == 1, result = 1; 	elseif keycode(h.abortkeycode), result = 1;	else 		while KbCheck(-3); end;         % wait until all keys are released.	endend% function result = DSTestResponse(h,isPressed,keycode,key1,key2,keyguess1,keyguess2)% % DSTestResponse returns 1 when good key is pressed, 0 if bad% % 2/28/18   JP created from prior uses% % result = 0;% if isPressed == 1% 	if keycode(key1) == 1, result = 1;  % tests FIVE possibiities% 	elseif keycode(key2) == 1, result = 1; %     elseif keycode(keyguess1) == 1, result = 1;%     elseif keycode(keyguess2) == 1, result = 1;%  	elseif keycode(h.abortkeycode), result = 1;% 	else % 		while KbCheck(-3); end;         % wait until all keys are released.% 	end% end%--------------------------------------------------------------------function RecreateWindow(window,h,cal)% RecreateWindow(window,h,el,os)% use at beginning and after eyelink recalibration% 9/5/14    jp created% 4/5/15    removed clut swap with new color model% 6/26/15   removed el from args% 6/30/15   renamed RecreateWindow and define window from scratch% 1/13/16   fix bug that prevented eyelink from displaying images%           removed new window, instead just restored background color% Screen('Close',window);                         % delete old window to recover memory% window = Screen(h.myscreen,'OpenWindow',cl.backgroundcolor,[],h.pixelsize);	% create graphics "window" for entire screen% Screen('LoadNormalizedGammaTable', h.myscreen, cl.GammaInverse);   % this loads the gamma correction into hardware% text properties% Screen('Preference', 'TextAntiAliasing', 0);    % need text in binary colorsScreen('TextFont',window,h.Font);Screen('TextSize',window,h.FontSize);      Screen('TextStyle',window,h.FontStyle);Screen(window,'FillRect',cal.backgroundRGB);  	% reset background colorScreen(window,'Flip');      